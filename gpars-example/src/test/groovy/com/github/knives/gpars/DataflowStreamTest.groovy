package com.github.knives.gpars

import groovyx.gpars.dataflow.stream.DataflowStream
import groovyx.gpars.group.DefaultPGroup
import groovyx.gpars.scheduler.ResizeablePool

import org.junit.Test

/**
 * Demonstrates concurrent implementation of the Sieve of Eratosthenes using dataflow tasks
 *
 * In principle, the algorithm consists of a concurrently run chained filters,
 * each of which detects whether the current number can be divided by a single prime number.
 * (generate nums 1, 2, 3, 4, 5, ...) -> (filter by mod 2) -> (filter by mod 3) -> (filter by mod 5) -> (filter by mod 7) -> (filter by mod 11) -> (caution! Primes falling out here)
 * The chain is built (grows) on the fly, whenever a new prime is found
 */
class DataflowStreamTest {
	/**
	 * We need a resizeable thread pool, since tasks consume threads while waiting blocked for values at DataflowQueue.val
	 */
	def group = new DefaultPGroup(new ResizeablePool(true))
	
	
	@Test
	void testDataflowStream() {
		final int requestedPrimeNumberCount = 100
		
		/**
		 * Generating candidate numbers
		 */
		final DataflowStream candidates = new DataflowStream()
		group.task {
			candidates.generate(2, {it + 1}, {it < 1000})
		}
		
		/**
		 * Consume Sieve output and add additional filters for all found primes
		 */
		def currentOutput = candidates
		requestedPrimeNumberCount.times {
			int prime = currentOutput.first
			println "Found: $prime"
			currentOutput = filter(currentOutput, prime)
		}
	}
	
	/**
	 * Chain a new filter for a particular prime number to the end of the Sieve
	 * @param inChannel The current end channel to consume
	 * @param prime The prime number to divide future prime candidates with
	 * @return A new channel ending the whole chain
	 */
	def filter(DataflowStream inChannel, int prime) {
		inChannel.filter { number ->
			group.task {
				number % prime != 0
			}
		}
	}
}
